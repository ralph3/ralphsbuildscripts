diff -Naur cdrtools-2.01/cdda2wav/cdda2wav.c cdrtools-2.01.patched/cdda2wav/cdda2wav.c
--- cdrtools-2.01/cdda2wav/cdda2wav.c	2004-08-24 11:06:14.000000000 -0400
+++ cdrtools-2.01.patched/cdda2wav/cdda2wav.c	2009-05-27 18:38:08.000000000 -0400
@@ -901,8 +901,8 @@
 
 
 #if !defined (HAVE_STRTOUL) || (HAVE_STRTOUL != 1)
-static unsigned int strtoul __PR(( const char *s1, char **s2, int base ));
-static unsigned int strtoul(s1, s2, base)
+static unsigned int _strtoul __PR(( const char *s1, char **s2, int base ));
+static unsigned int _strtoul(s1, s2, base)
         const char *s1;
         char **s2;
 	int base;
@@ -1941,7 +1941,7 @@
 		}
 		else {
 			char	*endptr;
-			unsigned arg = strtoul(optstr, &endptr, 10);
+			unsigned arg = _strtoul(optstr, &endptr, 10);
 			if (optstr != endptr
 				&& arg <= SHOW_MAX) {
 				*flagp |= arg;
@@ -2237,8 +2237,8 @@
 	if (trackspec) {
 		char * endptr;
 		char * endptr2;
-		track = strtoul(trackspec, &endptr, 10 );
-		endtrack = strtoul(endptr, &endptr2, 10 );
+		track = _strtoul(trackspec, &endptr, 10 );
+		endtrack = _strtoul(endptr, &endptr2, 10 );
 		if (endptr2 == endptr) {
 			endtrack = track;
 		} else if (track == endtrack) {
diff -Naur cdrtools-2.01/cdda2wav/config.h cdrtools-2.01.patched/cdda2wav/config.h
--- cdrtools-2.01/cdda2wav/config.h	2003-10-06 13:03:58.000000000 -0400
+++ cdrtools-2.01.patched/cdda2wav/config.h	2009-05-27 18:28:42.000000000 -0400
@@ -32,7 +32,7 @@
 #define CONCAT(a,b)	a/**/b
 #endif
 
-#include "lconfig.h"
+//#include "lconfig.h"
 
 /* temporary until a autoconf check is present */
 #ifdef	__BEOS__
diff -Naur cdrtools-2.01/cdrecord/cue.c cdrtools-2.01.patched/cdrecord/cue.c
--- cdrtools-2.01/cdrecord/cue.c	2004-03-02 15:00:53.000000000 -0500
+++ cdrtools-2.01.patched/cdrecord/cue.c	2009-05-27 18:40:29.000000000 -0400
@@ -249,7 +249,7 @@
 LOCAL	char	*peekword	__PR((void));
 LOCAL	char	*lineend	__PR((void));
 LOCAL	char	*markword	__PR((char *delim));
-LOCAL	char	getdelim	__PR((void));
+LOCAL	char	_getdelim	__PR((void));
 LOCAL	char	*getnextitem	__PR((char *delim));
 LOCAL	char	*neednextitem	__PR((char *delim));
 LOCAL	char	*nextword	__PR((void));
@@ -772,7 +772,7 @@
 	if (kp == NULL)
 		cueabort("Unknown filetype '%s'", word);
 
-	if (getdelim() == '/') {
+	if (_getdelim() == '/') {
 		word = needitem();
 		if (*astol(++word, &secsize) != '\0')
 			cueabort("Not a number '%s'", word);
@@ -1163,7 +1163,7 @@
 }
 
 LOCAL char
-getdelim()
+_getdelim()
 {
 	return (wordendc);
 }
diff -Naur cdrtools-2.01/include/schily.h cdrtools-2.01.patched/include/schily.h
--- cdrtools-2.01/include/schily.h	2004-03-04 19:30:40.000000000 -0500
+++ cdrtools-2.01.patched/include/schily.h	2009-05-27 18:25:48.000000000 -0400
@@ -108,7 +108,7 @@
 		/* 6th arg not const, fexecv forces av[ac] = NULL */
 extern	int	fexecv __PR((const char *, FILE *, FILE *, FILE *, int,
 							char **));
-extern	int	fexecve __PR((const char *, FILE *, FILE *, FILE *,
+extern	int	_fexecve __PR((const char *, FILE *, FILE *, FILE *,
 					char * const *, char * const *));
 extern	int	fspawnv __PR((FILE *, FILE *, FILE *, int, char * const *));
 extern	int	fspawnl __PR((FILE *, FILE *, FILE *,
@@ -187,7 +187,7 @@
 extern	char	*findbytes __PR((const void *, int, char));
 extern	int	findline __PR((const char *, char, const char *,
 							int, char **, int));
-extern	int	getline __PR((char *, int));
+extern	int	_getline __PR((char *, int));
 extern	int	getstr __PR((char *, int));
 extern	int	breakline __PR((char *, char, char **, int));
 extern	int	getallargs __PR((int *, char * const**, const char *, ...));
diff -Naur cdrtools-2.01/libscg/scsitransp.c cdrtools-2.01.patched/libscg/scsitransp.c
--- cdrtools-2.01/libscg/scsitransp.c	2004-06-17 16:20:27.000000000 -0400
+++ cdrtools-2.01.patched/libscg/scsitransp.c	2009-05-27 18:25:48.000000000 -0400
@@ -323,7 +323,7 @@
 
 	js_printf("%s", msg);
 	flush();
-	if (getline(okbuf, sizeof (okbuf)) == EOF)
+	if (_getline(okbuf, sizeof (okbuf)) == EOF)
 		exit(EX_BAD);
 	if (streql(okbuf, "y") || streql(okbuf, "yes") ||
 	    streql(okbuf, "Y") || streql(okbuf, "YES"))
diff -Naur cdrtools-2.01/libschily/fexec.c cdrtools-2.01.patched/libschily/fexec.c
--- cdrtools-2.01/libschily/fexec.c	2004-06-06 07:50:24.000000000 -0400
+++ cdrtools-2.01.patched/libschily/fexec.c	2009-05-27 18:25:48.000000000 -0400
@@ -159,7 +159,7 @@
 	} while (p != NULL);
 	va_end(args);
 
-	ret = fexecve(name, in, out, err, av, env);
+	ret = _fexecve(name, in, out, err, av, env);
 	if (av != xav)
 		free(av);
 	return (ret);
@@ -173,11 +173,11 @@
 	char *av[];
 {
 	av[ac] = NULL;			/*  force list to be null terminated */
-	return (fexecve(name, in, out, err, av, environ));
+	return (_fexecve(name, in, out, err, av, environ));
 }
 
 EXPORT int
-fexecve(name, in, out, err, av, env)
+_fexecve(name, in, out, err, av, env)
 	const char *name;
 	FILE *in, *out, *err;
 	char * const av[], * const env[];
diff -Naur cdrtools-2.01/libschily/stdio/fgetline.c cdrtools-2.01.patched/libschily/stdio/fgetline.c
--- cdrtools-2.01/libschily/stdio/fgetline.c	2004-08-08 07:02:05.000000000 -0400
+++ cdrtools-2.01.patched/libschily/stdio/fgetline.c	2009-05-27 18:25:48.000000000 -0400
@@ -64,7 +64,7 @@
 }
 
 EXPORT int
-getline(buf, len)
+_getline(buf, len)
 	char	*buf;
 	int	len;
 {
diff -Naur cdrtools-2.01/readcd/io.c cdrtools-2.01.patched/readcd/io.c
--- cdrtools-2.01/readcd/io.c	2002-12-25 09:13:28.000000000 -0500
+++ cdrtools-2.01.patched/readcd/io.c	2009-05-27 18:25:48.000000000 -0400
@@ -138,7 +138,7 @@
 		(*prt)(s, *lp, mini, maxi, dp);
 		flush();
 		line[0] = '\0';
-		if (getline(line, 80) == EOF)
+		if (_getline(line, 80) == EOF)
 			exit(EX_BAD);
 
 		linep = skipwhite(line);
@@ -205,7 +205,7 @@
 	printf("%r", form, args);
 	va_end(args);
 	flush();
-	if (getline(okbuf, sizeof(okbuf)) == EOF)
+	if (_getline(okbuf, sizeof(okbuf)) == EOF)
 		exit(EX_BAD);
 	if (okbuf[0] == '?') {
 		printf("Enter 'y', 'Y', 'yes' or 'YES' if you agree with the previous asked question.\n");
diff -Naur cdrtools-2.01/readcd/readcd.c cdrtools-2.01.patched/readcd/readcd.c
--- cdrtools-2.01/readcd/readcd.c	2004-09-08 13:24:14.000000000 -0400
+++ cdrtools-2.01.patched/readcd/readcd.c	2009-05-27 18:25:48.000000000 -0400
@@ -1651,7 +1651,7 @@
 		error("Copy from SCSI (%d,%d,%d) disk to file\n",
 					scg_scsibus(scgp), scg_target(scgp), scg_lun(scgp));
 		error("Enter filename [%s]: ", defname); flush();
-		(void) getline(filename, sizeof (filename));
+		(void) _getline(filename, sizeof (filename));
 	}
 
 	if (askrange) {
@@ -1820,7 +1820,7 @@
 		error("Copy from file to SCSI (%d,%d,%d) disk\n",
 					scg_scsibus(scgp), scg_target(scgp), scg_lun(scgp));
 		error("Enter filename [%s]: ", defname); flush();
-		(void) getline(filename, sizeof (filename));
+		(void) _getline(filename, sizeof (filename));
 		error("Notice: reading from file always starts at file offset 0.\n");
 
 		getlong("Enter starting sector for copy:", &addr, 0L, end-1);
diff -Naur cdrtools-2.01/scgcheck/dmaresid.c cdrtools-2.01.patched/scgcheck/dmaresid.c
--- cdrtools-2.01/scgcheck/dmaresid.c	2004-09-08 13:45:22.000000000 -0400
+++ cdrtools-2.01.patched/scgcheck/dmaresid.c	2009-05-27 18:25:48.000000000 -0400
@@ -64,7 +64,7 @@
 	printf("Ready to start test for working DMA residual count? Enter <CR> to continue: ");
 	fprintf(logfile, "**********> Testing for working DMA residual count.\n");
 	flushit();
-	(void) getline(abuf, sizeof (abuf));
+	(void) _getline(abuf, sizeof (abuf));
 
 	printf("**********> Testing for working DMA residual count == 0.\n");
 	fprintf(logfile, "**********> Testing for working DMA residual count == 0.\n");
@@ -95,7 +95,7 @@
 	printf("Ready to start test for working DMA residual count == DMA count? Enter <CR> to continue: ");
 	fprintf(logfile, "**********> Testing for working DMA residual count == DMA count.\n");
 	flushit();
-	(void) getline(abuf, sizeof (abuf));
+	(void) _getline(abuf, sizeof (abuf));
 	passed = TRUE;
 	dmacnt = cnt;
 	ret = xtinquiry(scgp, 0, dmacnt);
@@ -130,7 +130,7 @@
 	printf("Ready to start test for working DMA residual count == 1? Enter <CR> to continue: ");
 	fprintf(logfile, "**********> Testing for working DMA residual count == 1.\n");
 	flushit();
-	(void) getline(abuf, sizeof (abuf));
+	(void) _getline(abuf, sizeof (abuf));
 	passed = TRUE;
 	dmacnt = cnt+1;
 	ret = xtinquiry(scgp, cnt, dmacnt);
diff -Naur cdrtools-2.01/scgcheck/scgcheck.c cdrtools-2.01.patched/scgcheck/scgcheck.c
--- cdrtools-2.01/scgcheck/scgcheck.c	2004-09-08 13:49:48.000000000 -0400
+++ cdrtools-2.01.patched/scgcheck/scgcheck.c	2009-05-27 18:25:48.000000000 -0400
@@ -189,7 +189,7 @@
 			break;
 		error("Enter SCSI device name for bus scanning [%s]: ", device);
 		flushit();
-		(void) getline(device, sizeof (device));
+		(void) _getline(device, sizeof (device));
 		if (device[0] == '\0')
 			strcpy(device, "0,6,0");
 
@@ -227,7 +227,7 @@
 	do {
 		error("Enter SCSI device name [%s]: ", device);
 		flushit();
-		(void) getline(device, sizeof (device));
+		(void) _getline(device, sizeof (device));
 		if (device[0] == '\0')
 			strcpy(device, "0,6,0");
 
@@ -256,7 +256,7 @@
 
 	printf("Ready to start test for second SCSI open? Enter <CR> to continue: ");
 	flushit();
-	(void) getline(abuf, sizeof (abuf));
+	(void) _getline(abuf, sizeof (abuf));
 #define	CHECK_SECOND_OPEN
 #ifdef	CHECK_SECOND_OPEN
 	if (!streql(abuf, "n")) {
@@ -344,7 +344,7 @@
 
 	printf("Ready to start test for succeeded command? Enter <CR> to continue: ");
 	flushit();
-	(void) getline(abuf, sizeof (abuf));
+	(void) _getline(abuf, sizeof (abuf));
 	scgp->verbose++;
 	ret = inquiry(scgp, buf, sizeof (struct scsi_inquiry));
 	scg_vsetup(scgp);
diff -Naur cdrtools-2.01/scgcheck/sense.c cdrtools-2.01.patched/scgcheck/sense.c
--- cdrtools-2.01/scgcheck/sense.c	2003-03-27 05:59:52.000000000 -0500
+++ cdrtools-2.01.patched/scgcheck/sense.c	2009-05-27 18:25:48.000000000 -0400
@@ -66,7 +66,7 @@
 	printf("Ready to start test for failing command? Enter <CR> to continue: ");
 	fprintf(logfile, "**********> Testing for failed SCSI command.\n");
 	flushit();
-	(void)getline(abuf, sizeof(abuf));
+	(void)_getline(abuf, sizeof(abuf));
 /*	scgp->verbose++;*/
 	fillbytes(buf, sizeof(struct scsi_inquiry), '\0');
 	fillbytes((caddr_t)scgp->scmd, sizeof(*scgp->scmd), '\0');
@@ -82,13 +82,13 @@
 		printf("the test utility. Otherwise remove any medium from the drive.\n");
 		printf("Ready to start test for failing command? Enter <CR> to continue: ");
 		flushit();
-		(void)getline(abuf, sizeof(abuf));
+		(void)_getline(abuf, sizeof(abuf));
 		ret = test_unit_ready(scgp);
 		if (ret >= 0 || !scg_cmd_err(scgp)) {
 			printf("Test Unit Ready did not fail.\n");
 			printf("Ready to eject tray? Enter <CR> to continue: ");
 			flushit();
-			(void)getline(abuf, sizeof(abuf));
+			(void)_getline(abuf, sizeof(abuf));
 			scsi_unload(scgp, (cdr_t *)0);
 			ret = test_unit_ready(scgp);
 		}
@@ -127,7 +127,7 @@
 	printf("Ready to start test for sense data count? Enter <CR> to continue: ");
 	fprintf(logfile, "**********> Testing for SCSI sense data count.\n");
 	flushit();
-	(void)getline(abuf, sizeof(abuf));
+	(void)_getline(abuf, sizeof(abuf));
 	printf("Testing if at least CCS_SENSE_LEN (%d) is supported...\n", CCS_SENSE_LEN);
 	fprintf(logfile, "**********> Testing if at least CCS_SENSE_LEN (%d) is supported...\n", CCS_SENSE_LEN);
 	ret = sensecount(scgp, CCS_SENSE_LEN);
diff -Naur cdrtools-2.01/scgcheck/sense.c.orig cdrtools-2.01.patched/scgcheck/sense.c.orig
--- cdrtools-2.01/scgcheck/sense.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ cdrtools-2.01.patched/scgcheck/sense.c.orig	2003-03-27 05:59:52.000000000 -0500
@@ -0,0 +1,293 @@
+/* @(#)sense.c	1.4 03/03/27 Copyright 2001 J. Schilling */
+#ifndef lint
+static	char sccsid[] =
+	"@(#)sense.c	1.4 03/03/27 Copyright 2001 J. Schilling";
+#endif
+/*
+ *	Copyright (c) 2001 J. Schilling
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; see the file COPYING.  If not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <mconfig.h>
+#include <stdio.h>
+#include <stdxlib.h>
+#include <unixstd.h>
+#include <strdefs.h>
+#include <schily.h>
+#include <standard.h>
+
+#include <utypes.h>
+#include <btorder.h>
+#include <scg/scgcmd.h>
+#include <scg/scsidefs.h>
+#include <scg/scsireg.h>
+#include <scg/scsitransp.h>
+
+#include "cdrecord.h"
+#include "scgcheck.h"
+
+extern	char	*buf;			/* The transfer buffer */
+extern	long	bufsize;		/* The size of the transfer buffer */
+
+extern	FILE	*logfile;
+extern	char	unavail[];
+
+LOCAL	BOOL	inq_nofail = FALSE;
+
+
+EXPORT	void	sensetest	__PR((SCSI *scgp));
+LOCAL	int	sensecount	__PR((SCSI *scgp, int sensecnt));
+LOCAL	int	badinquiry	__PR((SCSI *scgp, caddr_t bp, int cnt, int sensecnt));
+LOCAL	int	bad_unit_ready	__PR((SCSI *scgp, int sensecnt));
+
+EXPORT void
+sensetest(scgp)
+	SCSI	*scgp;
+{
+	char	abuf[2];
+	int	ret;
+	int	sense_count = 0;
+	BOOL	passed = TRUE;
+
+	printf("Ready to start test for failing command? Enter <CR> to continue: ");
+	fprintf(logfile, "**********> Testing for failed SCSI command.\n");
+	flushit();
+	(void)getline(abuf, sizeof(abuf));
+/*	scgp->verbose++;*/
+	fillbytes(buf, sizeof(struct scsi_inquiry), '\0');
+	fillbytes((caddr_t)scgp->scmd, sizeof(*scgp->scmd), '\0');
+	ret = badinquiry(scgp, buf, sizeof(struct scsi_inquiry), CCS_SENSE_LEN);
+	scg_vsetup(scgp);
+	scg_errfflush(scgp, logfile);
+	if (ret >= 0 || !scg_cmd_err(scgp)) {
+		inq_nofail = TRUE;
+		printf("Inquiry did not fail.\n");
+		fprintf(logfile, "Inquiry did not fail.\n");
+		printf("This may be because the firmware in your drive is buggy.\n");
+		printf("If the current drive is not a CD-ROM drive please restart\n");
+		printf("the test utility. Otherwise remove any medium from the drive.\n");
+		printf("Ready to start test for failing command? Enter <CR> to continue: ");
+		flushit();
+		(void)getline(abuf, sizeof(abuf));
+		ret = test_unit_ready(scgp);
+		if (ret >= 0 || !scg_cmd_err(scgp)) {
+			printf("Test Unit Ready did not fail.\n");
+			printf("Ready to eject tray? Enter <CR> to continue: ");
+			flushit();
+			(void)getline(abuf, sizeof(abuf));
+			scsi_unload(scgp, (cdr_t *)0);
+			ret = test_unit_ready(scgp);
+		}
+	}
+	scg_vsetup(scgp);
+	scg_errfflush(scgp, logfile);
+/*	scgp->verbose--;*/
+	if (ret < 0 &&
+	    scgp->scmd->error == SCG_NO_ERROR &&
+	    scgp->scmd->ux_errno != 0 &&
+	    *(Uchar *)&scgp->scmd->scb != 0) {
+		printf("----------> SCSI failed command test PASSED\n");
+		fprintf(logfile, "----------> SCSI failed command test PASSED\n");
+	} else {
+		if (ret >= 0) {
+			printf("---------->	scg_cmd() returns not -1 (%d)\n", ret);
+			fprintf(logfile, "---------->	scg_cmd() returns not -1 (%d)\n", ret);
+		}
+		if (scgp->scmd->error != SCG_NO_ERROR) {
+			printf("---------->	SCSI Transport return != SCG_NO_ERROR (%d)\n", scgp->scmd->error);
+			fprintf(logfile, "---------->	SCSI Transport return != SCG_NO_ERROR (%d)\n", scgp->scmd->error);
+		}
+		if (scgp->scmd->ux_errno == 0) {
+			printf("---------->	UNIX errno set to 0\n");
+			fprintf(logfile, "---------->	UNIX errno set to 0\n");
+		}
+		if (*(Uchar *)&scgp->scmd->scb == 0) {
+			printf("---------->	SCSI status byte set to 0 (0x%x)\n", *(Uchar *)&scgp->scmd->scb & 0xFF);
+			fprintf(logfile, "---------->	SCSI status byte set to 0 (0x%x)\n", *(Uchar *)&scgp->scmd->scb & 0xFF);
+		}
+		printf("----------> SCSI failed command test FAILED\n");
+		fprintf(logfile, "----------> SCSI failed command test FAILED\n");
+	}
+
+
+	printf("Ready to start test for sense data count? Enter <CR> to continue: ");
+	fprintf(logfile, "**********> Testing for SCSI sense data count.\n");
+	flushit();
+	(void)getline(abuf, sizeof(abuf));
+	printf("Testing if at least CCS_SENSE_LEN (%d) is supported...\n", CCS_SENSE_LEN);
+	fprintf(logfile, "**********> Testing if at least CCS_SENSE_LEN (%d) is supported...\n", CCS_SENSE_LEN);
+	ret = sensecount(scgp, CCS_SENSE_LEN);
+	if (ret > sense_count)
+		sense_count = ret;
+	if (ret == CCS_SENSE_LEN) {
+		printf("---------->	Wanted %d sense bytes, got it.\n", CCS_SENSE_LEN);
+		fprintf(logfile, "---------->	Wanted %d sense bytes, got it.\n", CCS_SENSE_LEN);
+	}
+	if (ret != CCS_SENSE_LEN) {
+		printf("---------->	Minimum standard (CCS) sense length failed\n");
+		printf("---------->	Wanted %d sense bytes, got (%d)\n", CCS_SENSE_LEN, ret);
+		fprintf(logfile, "---------->	Minimum standard (CCS) sense length failed\n");
+		fprintf(logfile, "---------->	Wanted %d sense bytes, got (%d)\n", CCS_SENSE_LEN, ret);
+	}
+	if (ret != scgp->scmd->sense_count) {
+		passed = FALSE;
+		printf("---------->	Libscg says %d sense bytes but got (%d)\n", scgp->scmd->sense_count, ret);
+		fprintf(logfile, "---------->	Libscg says %d sense bytes but got (%d)\n", scgp->scmd->sense_count, ret);
+	}
+	printf("Testing for %d bytes of sense data...\n", SCG_MAX_SENSE);
+	fprintf(logfile, "**********> Testing for %d bytes of sense data...\n", SCG_MAX_SENSE);
+	ret = sensecount(scgp, SCG_MAX_SENSE);
+	if (ret > sense_count)
+		sense_count = ret;
+	if (ret == SCG_MAX_SENSE) {
+		printf("---------->	Wanted %d sense bytes, got it.\n", SCG_MAX_SENSE);
+		fprintf(logfile, "---------->	Wanted %d sense bytes, got it.\n", SCG_MAX_SENSE);
+	}
+	if (ret != SCG_MAX_SENSE) {
+		printf("---------->	Wanted %d sense bytes, got (%d)\n", SCG_MAX_SENSE, ret);
+		fprintf(logfile, "---------->	Wanted %d sense bytes, got (%d)\n", SCG_MAX_SENSE, ret);
+	}
+	if (ret != scgp->scmd->sense_count) {
+		passed = FALSE;
+		printf("---------->	Libscg says %d sense bytes but got (%d)\n", scgp->scmd->sense_count, ret);
+		fprintf(logfile, "---------->	Libscg says %d sense bytes but got (%d)\n", scgp->scmd->sense_count, ret);
+	}
+
+	printf("----------> Got a maximum of %d sense bytes\n", sense_count);
+	fprintf(logfile, "----------> Got a maximum of %d sense bytes\n", sense_count);
+	if (passed && sense_count >= CCS_SENSE_LEN) {
+		printf("----------> SCSI sense count test PASSED\n");
+		fprintf(logfile, "----------> SCSI sense count test PASSED\n");
+	} else {
+		printf("----------> SCSI sense count test FAILED\n");
+		fprintf(logfile, "----------> SCSI sense count test FAILED\n");
+	}
+}
+
+LOCAL int
+sensecount(scgp, sensecnt)
+	SCSI	*scgp;
+	int	sensecnt;
+{
+	int	maxcnt;
+	int	i;
+	Uchar	*p;
+
+	if (sensecnt > SCG_MAX_SENSE)
+		sensecnt = SCG_MAX_SENSE;
+		
+/*	scgp->verbose++;*/
+	scgp->silent++;
+	fillbytes(buf, sizeof(struct scsi_inquiry), '\0');
+	fillbytes((caddr_t)scgp->scmd, sizeof(*scgp->scmd), '\0');
+	fillbytes((caddr_t)scgp->scmd->u_sense.cmd_sense, sensecnt, 0x00);
+	if (inq_nofail)
+		bad_unit_ready(scgp, sensecnt);
+	else
+		badinquiry(scgp, buf, sizeof(struct scsi_inquiry), sensecnt);
+	scg_fprbytes(stdout,  "Sense Data:", (Uchar *)scgp->scmd->u_sense.cmd_sense, sensecnt);
+	scg_fprbytes(logfile, "Sense Data:", (Uchar *)scgp->scmd->u_sense.cmd_sense, sensecnt);
+	p = (Uchar *)scgp->scmd->u_sense.cmd_sense;
+	for (i=sensecnt-1; i >= 0; i--) {
+		if (p[i] != 0x00) {
+			break;
+		}
+	}
+	i++;
+	maxcnt = i;
+printf("---------->     Method 0x00: expected: %d reported: %d max found: %d\n", sensecnt, scgp->scmd->sense_count, maxcnt);
+
+	fillbytes(buf, sizeof(struct scsi_inquiry), '\0');
+	fillbytes((caddr_t)scgp->scmd, sizeof(*scgp->scmd), '\0');
+	fillbytes((caddr_t)scgp->scmd->u_sense.cmd_sense, sensecnt, 0xFF);
+	if (inq_nofail)
+		bad_unit_ready(scgp, sensecnt);
+	else
+		badinquiry(scgp, buf, sizeof(struct scsi_inquiry), sensecnt);
+	scg_fprbytes(stdout,  "Sense Data:", (Uchar *)scgp->scmd->u_sense.cmd_sense, sensecnt);
+	scg_fprbytes(logfile, "Sense Data:", (Uchar *)scgp->scmd->u_sense.cmd_sense, sensecnt);
+	p = (Uchar *)scgp->scmd->u_sense.cmd_sense;
+	for (i=sensecnt-1; i >= 0; i--) {
+		if (p[i] != 0xFF) {
+			break;
+		}
+	}
+	i++;
+	if (i > maxcnt)
+		maxcnt = i;
+printf("---------->     Method 0xFF: expected: %d reported: %d max found: %d\n", sensecnt, scgp->scmd->sense_count, i);
+
+/*	scgp->verbose--;*/
+	scgp->silent--;
+/*	scg_vsetup(scgp);*/
+/*	scg_errfflush(scgp, logfile);*/
+
+	return (maxcnt);
+}
+
+LOCAL int
+badinquiry(scgp, bp, cnt, sensecnt)
+	SCSI	*scgp;
+	caddr_t	bp;
+	int	cnt;
+	int	sensecnt;
+{
+	register struct	scg_cmd	*scmd = scgp->scmd;
+
+/*	fillbytes(bp, cnt, '\0');*/
+/*	fillbytes((caddr_t)scmd, sizeof(*scmd), '\0');*/
+	scmd->addr = bp;
+	scmd->size = cnt;
+	scmd->flags = SCG_RECV_DATA|SCG_DISRE_ENA;
+	scmd->cdb_len = SC_G0_CDBLEN;
+/*	scmd->sense_len = CCS_SENSE_LEN;*/
+	scmd->sense_len = sensecnt;
+	scmd->cdb.g0_cdb.cmd = SC_INQUIRY;
+	scmd->cdb.g0_cdb.lun = scg_lun(scgp);
+	scmd->cdb.g0_cdb.count = cnt;
+
+scmd->cdb.cmd_cdb[3] = 0xFF;
+	
+	scgp->cmdname = "inquiry";
+
+	if (scg_cmd(scgp) < 0)
+		return (-1);
+	if (scgp->verbose)
+		scg_prbytes("Inquiry Data   :", (Uchar *)bp, cnt - scg_getresid(scgp));
+	return (0);
+}
+
+LOCAL int
+bad_unit_ready(scgp, sensecnt)
+	SCSI	*scgp;
+	int	sensecnt;
+{
+	register struct	scg_cmd	*scmd = scgp->scmd;
+
+/*	fillbytes((caddr_t)scmd, sizeof(*scmd), '\0');*/
+	scmd->addr = (caddr_t)0;
+	scmd->size = 0;
+	scmd->flags = SCG_DISRE_ENA | (scgp->silent ? SCG_SILENT:0);
+	scmd->cdb_len = SC_G0_CDBLEN;
+	scmd->sense_len = sensecnt;
+	scmd->cdb.g0_cdb.cmd = SC_TEST_UNIT_READY;
+	scmd->cdb.g0_cdb.lun = scg_lun(scgp);
+	
+	scgp->cmdname = "test unit ready";
+
+	return (scg_cmd(scgp));
+}
