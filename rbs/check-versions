#!/bin/bash

[ "$(id -u)" != "0" ] && {
  echo "Run me as root please." >/dev/stderr
  exit 1
}

cd "$(dirname $0)" || exit 1
RBSDIR="$PWD"

source "$RBSDIR/shared" || exit 1

if [ -n "$1" ]; then
  PROFILES="$*"
else
  PROFILES="$(profile_list)"
fi

mkdir -p .cache/version_check_data || exit 1
echo "<check-versions begin>"
for PRO in $PROFILES; do
  profile_exists $PRO || {
    echo "No profile named \"${PRO}.sh\" found!" >/dev/stderr
    exit 1
  }
  PROFILE=$(profile_realpath $PRO)
  unset version_check_info VERSION APPNAME ADDRESS VERSION_STRING \
    VERSION_FILTERS ONLY_EVEN_MINORS MINOR_VERSION MIRRORS HIGH_MINOR_VERSION
  source $PROFILE || exit 1
  [ "$(type -t version_check_info)" == "function" ] && {
    version_check_info
/usr/bin/env python - "$PRO" \
                      "$(exec_profile $PRO VERSION)" \
                      "$ADDRESS" \
                      "$VERSION_STRING" \
                      "$ONLY_EVEN_MINORS" \
                      "$MINOR_VERSION" \
                      "$VERSION_FILTERS" \
                      "$(for m in "${MIRRORS[@]}"; do echo "$m"; done)" \
                      << "PYTHON_CODE"

import sys, os, re

def err_exit():
  print "</check-versions ERROR>"
  sys.exit(1)

open_msg_len = 0
def open_msg( msg ):
  global open_msg_len, message_closed
  message_closed = 0
  nmsg = " " + msg
  open_msg_len = len(nmsg)
  sys.stdout.write(nmsg)
  sys.stdout.flush()

def close_msg( msg ):
  global open_msg_len, message_closed
  if not message_closed:
    sys.stdout.write(msg + '\n')
    sys.stdout.flush()
    message_closed = 1

def high_version( v ):
  def vcmp(n1, n2):
    def ldigit(n):
      r = []
      x = 0
      l = len(n)
      while x < l:
        if n[x].isdigit():
          r.append(n[x])
        x += 1
      return int(''.join(r))
    s1 = n1.replace(".","_").replace("-","_").split('_')
    s2 = n2.replace(".","_").replace("-","_").split('_')
    lc = [ n1, s1 ]
    sc = [ n2, s2 ]
    if  len(s1) < len(s2):
      lc = [ n2, s2 ]
      sc = [ n1, s1 ]
    x = 0
    for y in sc[1]:
      if y.isdigit() and lc[1][x].isdigit():
        s = int(y)
        l = int(lc[1][x])
      else:
        s = y
        l = lc[1][x]
        if s.isdigit():
          ns = int(s)
        else:
          ns = ldigit(s)
        if l.isdigit():
          nl = int(l)
        else:
          nl = ldigit(l)
        if ns > nl:
          return sc[0]
        elif ns < nl:
          return lc[0]
      if s > l:
        return sc[0]
      elif s < l:
        return lc[0]
      x += 1
    return lc[0]
  h = v[0]
  for x in v:
    h = vcmp(h, x)
  return h

def fetch_data(address):
  h = os.popen("wget -O /dev/stdout --timeout=30 --passive-ftp \"" + address + "\" 2>/dev/null", 'r')
  d = h.read()
  h.close()
  if not d:
    close_msg("!!Error Fetching Data!!")
    err_exit()
  return d

def grep(regex,list):
  ret=[]
  for line in list:
    if re.search(regex,line):
      ret.append(line)
  return ret

def grep_v(regex,list):
  ret=[]
  for line in list:
    if not re.search(regex,line):
      ret.append(line)
  return ret

def minor_is_even(version):
  s = version.replace('_','.').replace('-','.').split('.')
  try:
    if s[1] and s[1].isdigit():
      i = int(s[1])
      if i/2*2 == i:
        return 1
      else:
        return 0
  except:
    return

def filter_versions(versions):
  global only_even_minors, version_filters, minor_version
  v = versions
  tv = []
  for x in v:
    if only_even_minors == '1' and minor_is_even(x):
      tv.append(x)
  if tv:
    v = tv
    tv = []
  for x in v:
    if minor_version and re.search("^"+minor_version,x):
      tv.append(x)
  if tv:
    v = tv
    tv = []
  for x in v:
    if version_filters:
      nogo = ''
      for y in version_filters.split(' '):
        if re.search(y,x):
          nogo = 1
      if not nogo:
        tv.append(x)
  if tv:
    return tv
  else:
    return v

def resolve_address(addy):
  global version, minor_version
  address = [addy]
  def res(a,s):
    while re.search(s, a):
      na = a.split(s)
      napre = os.path.basename(na[0])
      nalsuf = os.path.dirname(na[1][::-1])[::-1]
      if na[1][0] == '/':
        nasuf = '/'
      else:
        nasuf = os.path.basename(na[1][::-1])[::-1]
      na = os.path.dirname(na[0])
      n=[]
      data = fetch_data(na+'/')
      if napre:
        data = grep( napre + ".*" + nasuf, data.split("\n") )
        for line in data:
          sp = line.split(napre)[1].split(nasuf)[0]
          if '>' not in sp and '\"' not in sp and '\'' not in sp:
            n.append( sp )
      else:
        data = data.split("\n")
        tn = []
        for x in data:
          if 'href=' in x or 'HREF=' in x:
            l = x.replace('HREF=', 'href=')[::-1].split('=ferh')[0][::-1].split('>')[1].split('<')[0]
            if l and '>' not in l and '<' not in l and '\"' not in l and '\'' not in l and l[0].isdigit() and l[::-1][0] == '/':
              tn.append(l)
        tn = grep( ".*" + nasuf, tn )
        for x in tn:
          n.append(x.replace(nasuf, ''))
      h = high_version( filter_versions(n) )
      if nasuf == '/':
        nasuf = ''
      a = na + '/' + napre + h + nasuf + nalsuf
    return [a,h]
  try:
    if re.search("%minor_version%", address[0]):
      address = res(address[0],"%minor_version%")
      minor_version = address[1]
  except:
    close_msg("!!! error resolving minor version directory !!!")
    err_exit()
  try:
    if re.search("%version%", address[0]):
      address = res(address[0],"%version%")
      version = address[1]
  except:
    close_msg("!!! error resolving version directory !!!")
    err_exit()
  return address[0]

name             = sys.argv[1]
profile_version  = sys.argv[2]
address          = sys.argv[3]
version_string   = sys.argv[4]
only_even_minors = sys.argv[5]
minor_version    = sys.argv[6]
version_filters  = sys.argv[7]

open_msg("  " + name + ": ")

if not profile_version:
  close_msg("VERSION not set in profile.")
  err_exit()

if not address:
  close_msg("ADDRESS not set in profile.")
  err_exit()

if not version_string:
  close_msg("VERSION_STRING not set in profile.")
  err_exit()

if not version_string:
  close_msg("VERSION_STRING not set in profile.")
  err_exit()

if not sys.argv[8]:
  close_msg("MIRRORS not set in profile.")
  err_exit()
else:
  mirror_list      = sys.argv[8].split('\n')

version = ''
address = resolve_address(address)

if not version:
  try:
    vnums = []
    data = fetch_data(address)
    regex = version_string.replace(".","\.").replace("%version%", ".*").replace("+", "\+")
    data = grep( regex, data.split("\n") )
    vspre, vssuf = version_string.split("%version%")
    for line in data:
      l = line.replace(vspre,"\n").replace(vssuf,"\n").split('\n')[1]
      if l and l[0].isdigit():
        vnums.append( l )
    version = high_version( filter_versions(vnums) )
  except:
    close_msg("!!! internal error !!!")
    err_exit()

storedata = version + "\n\n"
for x in mirror_list:
  m = x.replace("%minor_version%", minor_version).replace("%version%", version)
  p = os.popen('wget --spider --timeout=30 --tries=1 --passive-ftp \"' + m + '\" 2>/dev/null')
  y = p.read()
  if not p.close():
    storedata = storedata + m + "\n"

try:
  f = open('.cache/version_check_data/' + name, 'w')
  f.write(storedata)
  f.close()
except:
  close_msg("!!! error updating cache !!!")
  err_exit()

if profile_version != version and high_version([profile_version, version]) == version:
  close_msg(profile_version + " -> " + version)
  sys.exit(0)
else:
  if not message_closed:
    for x in range( open_msg_len ):
      sys.stdout.write('\b')
    sys.stdout.flush()
    message_closed = 1
PYTHON_CODE
  }
done
echo "</check-versions end>"
exit 0
