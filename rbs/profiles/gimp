#!/bin/bash

DISABLE_MULTILIB=1

VERSION="2.6.11"

DIR="gimp-${VERSION}"
TARBALL="gimp-${VERSION}.tar.bz2"

SRC1=(
http://gimp.mirrors.hoobly.com/gimp/v2.6/${TARBALL}
ftp://ftp.cs.umn.edu/pub/gimp/v2.6/${TARBALL}
ftp://ftp.gimp.org/pub/gimp/v2.6/${TARBALL}
)

MD5SUMS=(
bb2939fe13e54fc7255cef5d097bb5dd
)

build(){
  unpack_tarball $TARBALL || return 1
  cd $SRCDIR/$DIR || return 1
  
cat << "EOF" | patch -Np1 || return 1
diff -Naur gimp-2.6.11/plug-ins/common/file-mng.c gimp-2.6.11.patched/plug-ins/common/file-mng.c
--- gimp-2.6.11/plug-ins/common/file-mng.c	2010-07-02 18:51:56.000000000 -0400
+++ gimp-2.6.11.patched/plug-ins/common/file-mng.c	2011-04-04 13:49:17.000000000 -0400
@@ -799,6 +799,13 @@
       png_infop       png_info_ptr;
       FILE           *infile, *outfile;
       int             num_passes;
+      int             color_type;
+      png_colorp      palette;
+      int             num_palette;
+      int             bit_depth;
+      png_bytep       trans_alpha;
+      int             num_trans;
+      png_color_16p   trans_color;
       int             tile_height;
       guchar        **layer_pixels, *layer_pixel;
       int             pass, j, k, begin, end, num;
@@ -969,7 +976,7 @@
           goto err3;
         }
 
-      if (setjmp (png_ptr->jmpbuf) != 0)
+      if (setjmp (png_jmpbuf(png_ptr)) != 0)
         {
           g_warning ("HRM saving PNG in mng_save_image()");
           png_destroy_write_struct (&png_ptr, &png_info_ptr);
@@ -981,34 +988,27 @@
       png_init_io (png_ptr, outfile);
       png_set_compression_level (png_ptr, mng_data.compression_level);
 
-      png_info_ptr->width = layer_cols;
-      png_info_ptr->height = layer_rows;
-      png_info_ptr->interlace_type = (mng_data.interlaced == 0 ? 0 : 1);
-      png_info_ptr->bit_depth = 8;
-
       switch (layer_drawable_type)
         {
         case GIMP_RGB_IMAGE:
-          png_info_ptr->color_type = PNG_COLOR_TYPE_RGB;
+          color_type = PNG_COLOR_TYPE_RGB;
           break;
         case GIMP_RGBA_IMAGE:
-          png_info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
+          color_type = PNG_COLOR_TYPE_RGB_ALPHA;
           break;
         case GIMP_GRAY_IMAGE:
-          png_info_ptr->color_type = PNG_COLOR_TYPE_GRAY;
+          color_type = PNG_COLOR_TYPE_GRAY;
           break;
         case GIMP_GRAYA_IMAGE:
-          png_info_ptr->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
+          color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
           break;
         case GIMP_INDEXED_IMAGE:
-          png_info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
-          png_info_ptr->valid |= PNG_INFO_PLTE;
-          png_info_ptr->palette =
-            (png_colorp) gimp_image_get_colormap (image_id, &num_colors);
-          png_info_ptr->num_palette = num_colors;
+          color_type = PNG_COLOR_TYPE_PALETTE;
+
+          png_set_PLTE(png_ptr, png_info_ptr, (png_colorp) gimp_image_get_colormap (image_id, &num_colors), num_colors);
           break;
         case GIMP_INDEXEDA_IMAGE:
-          png_info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
+          color_type = PNG_COLOR_TYPE_PALETTE;
           layer_has_unique_palette =
             respin_cmap (png_ptr, png_info_ptr, layer_remap,
                          image_id, layer_drawable);
@@ -1021,15 +1021,17 @@
           goto err3;
         }
 
-      if ((png_info_ptr->valid & PNG_INFO_PLTE) == PNG_INFO_PLTE)
+      bit_depth = 8;
+      if (png_get_PLTE(png_ptr, png_info_ptr, &palette, &num_palette) != 0)
         {
-          if (png_info_ptr->num_palette <= 2)
-            png_info_ptr->bit_depth = 1;
-          else if (png_info_ptr->num_palette <= 4)
-            png_info_ptr->bit_depth = 2;
-          else if (png_info_ptr->num_palette <= 16)
-            png_info_ptr->bit_depth = 4;
+          if (num_palette <= 2)
+            bit_depth = 1;
+          else if (num_palette <= 4)
+            bit_depth = 2;
+          else if (num_palette <= 16)
+            bit_depth = 4;
         }
+      png_set_IHDR(png_ptr, png_info_ptr, layer_cols, layer_rows, bit_depth, color_type, (mng_data.interlaced == 0 ? PNG_INTERLACE_NONE : PNG_INTERLACE_ADAM7), PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
 
       png_write_info (png_ptr, png_info_ptr);
 
@@ -1038,8 +1040,8 @@
       else
         num_passes = 1;
 
-      if ((png_info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) &&
-          (png_info_ptr->bit_depth < 8))
+      if ((png_get_color_type(png_ptr, png_info_ptr) == PNG_COLOR_TYPE_PALETTE) &&
+          (png_get_bit_depth(png_ptr, png_info_ptr) < 8))
         png_set_packing (png_ptr);
 
       tile_height = gimp_tile_height ();
@@ -1065,7 +1067,7 @@
               gimp_pixel_rgn_get_rect (&layer_pixel_rgn, layer_pixel, 0,
                                        begin, layer_cols, num);
 
-              if ((png_info_ptr->valid & PNG_INFO_tRNS) == PNG_INFO_tRNS)
+              if (png_get_tRNS(png_ptr, png_info_ptr, &trans_alpha, &num_trans, &trans_color) != 0)
                 {
                   for (j = 0; j < num; j++)
                     {
@@ -1077,7 +1079,7 @@
                     }
                 }
               else
-                if (((png_info_ptr->valid & PNG_INFO_PLTE) == PNG_INFO_PLTE)
+                if ((png_get_PLTE(png_ptr, png_info_ptr, &palette, &num_palette) != 0)
                     && (layer_bpp == 2))
                 {
                   for (j = 0; j < num; j++)
diff -Naur gimp-2.6.11/plug-ins/common/file-png.c gimp-2.6.11.patched/plug-ins/common/file-png.c
--- gimp-2.6.11/plug-ins/common/file-png.c	2010-07-13 16:22:27.000000000 -0400
+++ gimp-2.6.11.patched/plug-ins/common/file-png.c	2011-04-04 13:49:27.000000000 -0400
@@ -653,7 +653,11 @@
                                 error_data->drawable->width, num);
     }
 
+#if (PNG_LIBPNG_VER < 10500)
   longjmp (png_ptr->jmpbuf, 1);
+#else
+  png_longjmp (png_ptr, 1);
+#endif
 }
 
 /*
@@ -697,7 +701,7 @@
   pp = png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
   info = png_create_info_struct (pp);
 
-  if (setjmp (pp->jmpbuf))
+  if (setjmp (png_jmpbuf(pp)))
     {
       g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                    _("Error while reading '%s'. File corrupted?"),
@@ -738,17 +742,19 @@
    * Latest attempt, this should be my best yet :)
    */
 
-  if (info->bit_depth == 16)
+  if (png_get_bit_depth(pp, info) == 16)
     {
       png_set_strip_16 (pp);
     }
 
-  if (info->color_type == PNG_COLOR_TYPE_GRAY && info->bit_depth < 8)
+  if (png_get_color_type(pp, info) == PNG_COLOR_TYPE_GRAY &&
+      png_get_bit_depth(pp, info) < 8)
     {
       png_set_expand (pp);
     }
 
-  if (info->color_type == PNG_COLOR_TYPE_PALETTE && info->bit_depth < 8)
+  if (png_get_color_type(pp, info) == PNG_COLOR_TYPE_PALETTE &&
+      png_get_bit_depth(pp, info) < 8)
     {
       png_set_packing (pp);
     }
@@ -757,8 +763,8 @@
    * Expand G+tRNS to GA, RGB+tRNS to RGBA
    */
 
-  if (info->color_type != PNG_COLOR_TYPE_PALETTE &&
-      (info->valid & PNG_INFO_tRNS))
+  if (png_get_color_type(pp, info) != PNG_COLOR_TYPE_PALETTE &&
+      png_get_valid(pp, info, PNG_INFO_tRNS) != 0)
     {
       png_set_expand (pp);
     }
@@ -775,7 +781,7 @@
    */
 
   if (png_get_valid (pp, info, PNG_INFO_tRNS) &&
-      info->color_type == PNG_COLOR_TYPE_PALETTE)
+      png_get_color_type(pp, info) == PNG_COLOR_TYPE_PALETTE)
     {
       png_get_tRNS (pp, info, &alpha_ptr, &num, NULL);
       /* Copy the existing alpha values from the tRNS chunk */
@@ -797,7 +803,7 @@
 
   png_read_update_info (pp, info);
 
-  switch (info->color_type)
+  switch (png_get_color_type(pp, info))
     {
     case PNG_COLOR_TYPE_RGB:           /* RGB */
       bpp = 3;
@@ -836,7 +842,9 @@
       return -1;
     }
 
-  image = gimp_image_new (info->width, info->height, image_type);
+  image = gimp_image_new (png_get_image_width(pp, info),
+                          png_get_image_height(pp, info),
+                          image_type);
   if (image == -1)
     {
       g_set_error (error, 0, 0,
@@ -849,7 +857,9 @@
    * Create the "background" layer to hold the image...
    */
 
-  layer = gimp_layer_new (image, _("Background"), info->width, info->height,
+  layer = gimp_layer_new (image, _("Background"),
+                          png_get_image_width(pp, info),
+                          png_get_image_height(pp, info),
                           layer_type, 100, GIMP_NORMAL_MODE);
   gimp_image_add_layer (image, layer, 0);
 
@@ -883,7 +893,8 @@
 
       gimp_layer_set_offsets (layer, offset_x, offset_y);
 
-      if ((abs (offset_x) > info->width) || (abs (offset_y) > info->height))
+      if ((abs (offset_x) > png_get_image_width(pp, info)) ||
+          (abs (offset_y) > png_get_image_height(pp, info)))
         {
           if (interactive)
             g_message (_("The PNG file specifies an offset that caused "
@@ -938,23 +949,27 @@
 
   empty = 0; /* by default assume no full transparent palette entries */
 
-  if (info->color_type & PNG_COLOR_MASK_PALETTE)
+  if (png_get_color_type(pp, info) & PNG_COLOR_MASK_PALETTE)
     {
+      png_colorp palette;
+      int num_palette;
+      png_get_PLTE(pp, info, &palette, &num_palette);
+
       if (png_get_valid (pp, info, PNG_INFO_tRNS))
         {
           for (empty = 0; empty < 256 && alpha[empty] == 0; ++empty)
             /* Calculates number of fully transparent "empty" entries */;
 
           /*  keep at least one entry  */
-          empty = MIN (empty, info->num_palette - 1);
+          empty = MIN (empty, num_palette - 1);
 
-          gimp_image_set_colormap (image, (guchar *) (info->palette + empty),
-                                   info->num_palette - empty);
+          gimp_image_set_colormap (image, (guchar *) (palette + empty),
+                                   num_palette - empty);
         }
       else
         {
-          gimp_image_set_colormap (image, (guchar *) info->palette,
-                                   info->num_palette);
+          gimp_image_set_colormap (image, (guchar *) palette,
+                                   num_palette);
         }
     }
 
@@ -972,18 +987,20 @@
    */
 
   tile_height = gimp_tile_height ();
-  pixel = g_new0 (guchar, tile_height * info->width * bpp);
+  pixel = g_new0 (guchar, tile_height * png_get_image_width(pp, info) * bpp);
   pixels = g_new (guchar *, tile_height);
 
   for (i = 0; i < tile_height; i++)
-    pixels[i] = pixel + info->width * info->channels * i;
+    pixels[i] = pixel + (png_get_image_width(pp, info) *
+                         png_get_channels(pp, info) *
+                         i);
 
   /* Install our own error handler to handle incomplete PNG files better */
   error_data.drawable    = drawable;
   error_data.pixel       = pixel;
   error_data.tile_height = tile_height;
-  error_data.width       = info->width;
-  error_data.height      = info->height;
+  error_data.width       = png_get_image_width(pp, info);
+  error_data.height      = png_get_image_height(pp, info);
   error_data.bpp         = bpp;
   error_data.pixel_rgn   = &pixel_rgn;
 
@@ -996,10 +1013,11 @@
        */
 
       for (begin = 0, end = tile_height;
-           begin < info->height; begin += tile_height, end += tile_height)
+           begin < png_get_image_height(pp, info);
+           begin += tile_height, end += tile_height)
         {
-          if (end > info->height)
-            end = info->height;
+          if (end > png_get_image_height(pp, info))
+            end = png_get_image_height(pp, info);
 
           num = end - begin;
 
@@ -1016,10 +1034,11 @@
           gimp_pixel_rgn_set_rect (&pixel_rgn, pixel, 0, begin,
                                    drawable->width, num);
 
-          memset (pixel, 0, tile_height * info->width * bpp);
+          memset (pixel, 0, tile_height * png_get_image_width(pp, info) * bpp);
 
           gimp_progress_update (((gdouble) pass +
-                                 (gdouble) end / (gdouble) info->height) /
+                                 (gdouble) end /
+                                 (gdouble) png_get_image_height(pp, info)) /
                                 (gdouble) num_passes);
         }
     }
@@ -1072,7 +1091,8 @@
 
   {
     png_uint_32 proflen;
-    png_charp   profname, profile;
+    png_charp   profname;
+    png_bytep   profile;
     int         profcomp;
 
     if (png_get_iCCP (pp, info, &profname, &profcomp, &profile, &proflen))
@@ -1200,6 +1220,8 @@
   guchar red, green, blue;      /* Used for palette background */
   time_t cutime;                /* Time since epoch */
   struct tm *gmt;               /* GMT broken down */
+  int color_type;               /* type of colors in image */
+  int bit_depth;                /* width of colors in bit */
 
   guchar remap[256];            /* Re-mapping for the palette */
 
@@ -1208,7 +1230,9 @@
   if (pngvals.comment)
     {
       GimpParasite *parasite;
+#ifndef PNG_iTXt_SUPPORTED
       gsize text_length = 0;
+#endif
 
       parasite = gimp_image_parasite_find (orig_image_ID, "gimp-comment");
       if (parasite)
@@ -1249,7 +1273,7 @@
   pp = png_create_write_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
   info = png_create_info_struct (pp);
 
-  if (setjmp (pp->jmpbuf))
+  if (setjmp (png_jmpbuf(pp)))
     {
       g_set_error (error, 0, 0,
                    _("Error while saving '%s'. Could not save image."),
@@ -1291,11 +1315,6 @@
 
   png_set_compression_level (pp, pngvals.compression_level);
 
-  info->width          = drawable->width;
-  info->height         = drawable->height;
-  info->bit_depth      = 8;
-  info->interlace_type = pngvals.interlaced;
-
   /*
    * Initialise remap[]
    */
@@ -1309,37 +1328,36 @@
   switch (type)
     {
     case GIMP_RGB_IMAGE:
-      info->color_type = PNG_COLOR_TYPE_RGB;
+      color_type = PNG_COLOR_TYPE_RGB;
       bpp = 3;
       break;
 
     case GIMP_RGBA_IMAGE:
-      info->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
+      color_type = PNG_COLOR_TYPE_RGB_ALPHA;
       bpp = 4;
       break;
 
     case GIMP_GRAY_IMAGE:
-      info->color_type = PNG_COLOR_TYPE_GRAY;
+      color_type = PNG_COLOR_TYPE_GRAY;
       bpp = 1;
       break;
 
     case GIMP_GRAYA_IMAGE:
-      info->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
+      color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
       bpp = 2;
       break;
 
     case GIMP_INDEXED_IMAGE:
       bpp = 1;
-      info->color_type = PNG_COLOR_TYPE_PALETTE;
-      info->valid |= PNG_INFO_PLTE;
-      info->palette =
-        (png_colorp) gimp_image_get_colormap (image_ID, &num_colors);
-      info->num_palette = num_colors;
+      color_type = PNG_COLOR_TYPE_PALETTE;
+      png_set_PLTE(pp, info,
+                   (png_colorp) gimp_image_get_colormap (image_ID, &num_colors),
+                   num_colors);
       break;
 
     case GIMP_INDEXEDA_IMAGE:
       bpp = 2;
-      info->color_type = PNG_COLOR_TYPE_PALETTE;
+      color_type = PNG_COLOR_TYPE_PALETTE;
       /* fix up transparency */
       respin_cmap (pp, info, remap, image_ID, drawable);
       break;
@@ -1353,17 +1371,28 @@
    * Fix bit depths for (possibly) smaller colormap images
    */
 
-  if (info->valid & PNG_INFO_PLTE)
+  bit_depth = 8;
+
+  if (png_get_valid(pp, info, PNG_INFO_PLTE))
     {
-      if (info->num_palette <= 2)
-        info->bit_depth = 1;
-      else if (info->num_palette <= 4)
-        info->bit_depth = 2;
-      else if (info->num_palette <= 16)
-        info->bit_depth = 4;
+      png_colorp palette;
+      int num_palette;
+      png_get_PLTE(pp, info, &palette, &num_palette);
+      
+      if (num_palette <= 2)
+        bit_depth = 1;
+      else if (num_palette <= 4)
+        bit_depth = 2;
+      else if (num_palette <= 16)
+        bit_depth = 4;
       /* otherwise the default is fine */
     }
 
+  png_set_IHDR(pp, info,
+               drawable->width, drawable->height, bit_depth, color_type,
+               pngvals.interlaced ? PNG_INTERLACE_ADAM7 : PNG_INTERLACE_NONE,
+               PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
+
   /* All this stuff is optional extras, if the user is aiming for smallest
      possible file size she can turn them all off */
 
@@ -1477,7 +1506,8 @@
    * Convert unpacked pixels to packed if necessary
    */
 
-  if (info->color_type == PNG_COLOR_TYPE_PALETTE && info->bit_depth < 8)
+  if (png_get_color_type(pp, info) ==
+      PNG_COLOR_TYPE_PALETTE && png_get_bit_depth(pp, info) < 8)
     png_set_packing (pp);
 
   /*
@@ -1529,7 +1559,7 @@
 
           /* If we're dealing with a paletted image with
            * transparency set, write out the remapped palette */
-          if (info->valid & PNG_INFO_tRNS)
+          if (png_get_valid(pp, info, PNG_INFO_tRNS))
             {
               guchar inverse_remap[256];
 
@@ -1549,7 +1579,7 @@
             }
           /* Otherwise if we have a paletted image and transparency
            * couldn't be set, we ignore the alpha channel */
-          else if (info->valid & PNG_INFO_PLTE && bpp == 2)
+          else if (png_get_valid(pp, info, PNG_INFO_PLTE) && bpp == 2)
             {
               for (i = 0; i < num; ++i)
                 {
@@ -1564,7 +1594,7 @@
           png_write_rows (pp, pixels, num);
 
           gimp_progress_update (((double) pass + (double) end /
-                                 (double) info->height) /
+                                 (double) png_get_image_height(pp, info)) /
                                 (double) num_passes);
         }
     }
EOF
  

cat << "EOF" | patch -Np1 || return 1
From 69f69eed816b89be9a01a48a1f0643d1fd496118 Mon Sep 17 00:00:00 2001
From: Nils Philippsen <nils@redhat.com>
Date: Fri, 6 May 2011 11:58:44 +0200
Subject: [PATCH] patch: poppler-0.17

Squashed commit of the following:

commit 529d940222dfc352d41fbf72de29134421aa4002
Author: Nils Philippsen <nils@redhat.com>
Date:   Fri May 6 11:50:30 2011 +0200

    use code based on pixbufs instead of cairo surfaces

    this is done to avoid adding to libgimp, thanks to Mukund Sivaraman for
    hints how to do this

commit f8671d8767d4cdab830dc06310e96c63a88ec0fd
Author: Mukund Sivaraman <muks@banu.com>
Date:   Thu Apr 21 13:57:13 2011 +0530

    file-pdf-load: Update attribution, removing bogus copyright
    (cherry picked from commit e999122e0b20b6ccd6bde3ce039bb64068fc0019)

commit 89a78f2590d298dac2f42e6d9a3016fc5d672c70
Author: Nils Philippsen <nils@redhat.com>
Date:   Thu Apr 21 13:52:18 2011 +0200

    file-pdf-load: Use better API + cleanups

    * fixes issues with poppler 0.17 completely
    * uses new libgimp API to pass surfaces instead of pixbufs
    * uses GTK+ 3 API to convert surfaces to pixbufs where available
    (backported from commit 7bdadd80ba479d6ff904e276d805e16f6b940ee2)

commit 4e92302c4a14a961f112587a0ad86696c88da2f8
Author: Nils Philippsen <nils@redhat.com>
Date:   Thu Apr 21 13:38:08 2011 +0200

    file-pdf-load: Don't use deprecated API (bug #646947)

    (cherry picked from commit 9b3e1c91fd2eac69da6947ec9c7fbf10096ba237)

    Conflicts:

    	plug-ins/common/file-pdf.c
---
 plug-ins/common/file-pdf.c |  323 ++++++++++++++++++++++++++++++++++++++------
 1 files changed, 283 insertions(+), 40 deletions(-)

diff --git a/plug-ins/common/file-pdf.c b/plug-ins/common/file-pdf.c
index a43b459..43c2b7d 100644
--- a/plug-ins/common/file-pdf.c
+++ b/plug-ins/common/file-pdf.c
@@ -4,6 +4,9 @@
  *
  * Copyright (C) 2005 Nathan Summers
  *
+ * Some code in render_page_to_surface() borrowed from
+ * poppler.git/glib/poppler-page.cc.
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -80,16 +83,20 @@ static gboolean          load_dialog       (PopplerDocument        *doc,
 static PopplerDocument * open_document     (const gchar            *filename,
                                             GError                **error);
 
-static GdkPixbuf *       get_thumbnail     (PopplerDocument        *doc,
+static cairo_surface_t * get_thumb_surface (PopplerDocument        *doc,
+                                            gint                    page,
+                                            gint                    preferred_size);
+
+static GdkPixbuf *       get_thumb_pixbuf  (PopplerDocument        *doc,
                                             gint                    page,
                                             gint                    preferred_size);
 
 static gint32            layer_from_pixbuf (gint32                  image,
-                                            const gchar            *layer_name,
-                                            gint                    position,
-                                            GdkPixbuf              *buf,
-                                            gdouble                 progress_start,
-                                            gdouble                 progress_scale);
+					                        const gchar            *layer_name,
+					                        gint                    position,
+					                        GdkPixbuf              *pixbuf,
+					                        gdouble                 progress_start,
+					                        gdouble                 progress_scale);
 
 /**
  ** the following was formerly part of
@@ -433,11 +440,12 @@ run (const gchar      *name,
         }
       else
         {
-          gdouble      width  = 0;
-          gdouble      height = 0;
-          gdouble      scale;
-          gint32       image  = -1;
-          GdkPixbuf   *pixbuf = NULL;
+          gdouble    width     = 0;
+          gdouble    height    = 0;
+          gdouble    scale;
+          gint32     image     = -1;
+          gint       num_pages = 0;
+          GdkPixbuf *pixbuf    = NULL;
 
           /* Possibly retrieve last settings */
           gimp_get_data (LOAD_PROC, &loadvals);
@@ -455,7 +463,10 @@ run (const gchar      *name,
                   g_object_unref (page);
                 }
 
-              pixbuf = get_thumbnail (doc, 0, param[1].data.d_int32);
+              num_pages = poppler_document_get_n_pages (doc);
+
+              pixbuf = get_thumb_pixbuf (doc, 0, param[1].data.d_int32);
+
               g_object_unref (doc);
             }
 
@@ -548,6 +559,187 @@ open_document (const gchar  *filename,
   return doc;
 }
 
+/* FIXME: Remove this someday when we depend fully on GTK+ >= 3 */
+
+#if (!GTK_CHECK_VERSION (3, 0, 0))
+
+static cairo_format_t
+gdk_cairo_format_for_content (cairo_content_t content)
+{
+  switch (content)
+    {
+    case CAIRO_CONTENT_COLOR:
+      return CAIRO_FORMAT_RGB24;
+    case CAIRO_CONTENT_ALPHA:
+      return CAIRO_FORMAT_A8;
+    case CAIRO_CONTENT_COLOR_ALPHA:
+    default:
+      return CAIRO_FORMAT_ARGB32;
+    }
+}
+
+static cairo_surface_t *
+gdk_cairo_surface_coerce_to_image (cairo_surface_t *surface,
+                                   cairo_content_t  content,
+                                   int              src_x,
+                                   int              src_y,
+                                   int              width,
+                                   int              height)
+{
+  cairo_surface_t *copy;
+  cairo_t *cr;
+
+  copy = cairo_image_surface_create (gdk_cairo_format_for_content (content),
+                                     width,
+                                     height);
+
+  cr = cairo_create (copy);
+  cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
+  cairo_set_source_surface (cr, surface, -src_x, -src_y);
+  cairo_paint (cr);
+  cairo_destroy (cr);
+
+  return copy;
+}
+
+static void
+convert_alpha (guchar *dest_data,
+               int     dest_stride,
+               guchar *src_data,
+               int     src_stride,
+               int     src_x,
+               int     src_y,
+               int     width,
+               int     height)
+{
+  int x, y;
+
+  src_data += src_stride * src_y + src_x * 4;
+
+  for (y = 0; y < height; y++) {
+    guint32 *src = (guint32 *) src_data;
+
+    for (x = 0; x < width; x++) {
+      guint alpha = src[x] >> 24;
+
+      if (alpha == 0)
+        {
+          dest_data[x * 4 + 0] = 0;
+          dest_data[x * 4 + 1] = 0;
+          dest_data[x * 4 + 2] = 0;
+        }
+      else
+        {
+          dest_data[x * 4 + 0] = (((src[x] & 0xff0000) >> 16) * 255 + alpha / 2) / alpha;
+          dest_data[x * 4 + 1] = (((src[x] & 0x00ff00) >>  8) * 255 + alpha / 2) / alpha;
+          dest_data[x * 4 + 2] = (((src[x] & 0x0000ff) >>  0) * 255 + alpha / 2) / alpha;
+        }
+      dest_data[x * 4 + 3] = alpha;
+    }
+
+    src_data += src_stride;
+    dest_data += dest_stride;
+  }
+}
+
+static void
+convert_no_alpha (guchar *dest_data,
+                  int     dest_stride,
+                  guchar *src_data,
+                  int     src_stride,
+                  int     src_x,
+                  int     src_y,
+                  int     width,
+                  int     height)
+{
+  int x, y;
+
+  src_data += src_stride * src_y + src_x * 4;
+
+  for (y = 0; y < height; y++) {
+    guint32 *src = (guint32 *) src_data;
+
+    for (x = 0; x < width; x++) {
+      dest_data[x * 3 + 0] = src[x] >> 16;
+      dest_data[x * 3 + 1] = src[x] >>  8;
+      dest_data[x * 3 + 2] = src[x];
+    }
+
+    src_data += src_stride;
+    dest_data += dest_stride;
+  }
+}
+
+/**
+ * gdk_pixbuf_get_from_surface:
+ * @surface: surface to copy from
+ * @src_x: Source X coordinate within @surface
+ * @src_y: Source Y coordinate within @surface
+ * @width: Width in pixels of region to get
+ * @height: Height in pixels of region to get
+ *
+ * Transfers image data from a #cairo_surface_t and converts it to an RGB(A)
+ * representation inside a #GdkPixbuf. This allows you to efficiently read
+ * individual pixels from cairo surfaces. For #GdkWindows, use
+ * gdk_pixbuf_get_from_window() instead.
+ *
+ * This function will create an RGB pixbuf with 8 bits per channel.
+ * The pixbuf will contain an alpha channel if the @surface contains one.
+ *
+ * Return value: (transfer full): A newly-created pixbuf with a reference
+ *     count of 1, or %NULL on error
+ */
+static GdkPixbuf *
+gdk_pixbuf_get_from_surface  (cairo_surface_t *surface,
+                              gint             src_x,
+                              gint             src_y,
+                              gint             width,
+                              gint             height)
+{
+  cairo_content_t content;
+  GdkPixbuf *dest;
+
+  /* General sanity checks */
+  g_return_val_if_fail (surface != NULL, NULL);
+  g_return_val_if_fail (width > 0 && height > 0, NULL);
+
+  content = cairo_surface_get_content (surface) | CAIRO_CONTENT_COLOR;
+  dest = gdk_pixbuf_new (GDK_COLORSPACE_RGB,
+                         !!(content & CAIRO_CONTENT_ALPHA),
+                         8,
+                         width, height);
+
+  surface = gdk_cairo_surface_coerce_to_image (surface, content,
+                                               src_x, src_y,
+                                               width, height);
+  cairo_surface_flush (surface);
+  if (cairo_surface_status (surface) || dest == NULL)
+    {
+      cairo_surface_destroy (surface);
+      return NULL;
+    }
+
+  if (gdk_pixbuf_get_has_alpha (dest))
+    convert_alpha (gdk_pixbuf_get_pixels (dest),
+                   gdk_pixbuf_get_rowstride (dest),
+                   cairo_image_surface_get_data (surface),
+                   cairo_image_surface_get_stride (surface),
+                   0, 0,
+                   width, height);
+  else
+    convert_no_alpha (gdk_pixbuf_get_pixels (dest),
+                      gdk_pixbuf_get_rowstride (dest),
+                      cairo_image_surface_get_data (surface),
+                      cairo_image_surface_get_stride (surface),
+                      0, 0,
+                      width, height);
+
+  cairo_surface_destroy (surface);
+  return dest;
+}
+
+#endif
+
 static gint32
 layer_from_pixbuf (gint32        image,
                    const gchar  *layer_name,
@@ -566,6 +758,54 @@ layer_from_pixbuf (gint32        image,
   return layer;
 }
 
+static cairo_surface_t *
+render_page_to_surface (PopplerPage *page,
+                        int          width,
+                        int          height,
+                        double       scale)
+{
+  cairo_surface_t *surface;
+  cairo_t *cr;
+
+  surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, width, height);
+  cr = cairo_create (surface);
+
+  cairo_save (cr);
+  cairo_translate (cr, 0.0, 0.0);
+
+  if (scale != 1.0)
+    cairo_scale (cr, scale, scale);
+
+  poppler_page_render (page, cr);
+  cairo_restore (cr);
+
+  cairo_set_operator (cr, CAIRO_OPERATOR_DEST_OVER);
+  cairo_set_source_rgb (cr, 1.0, 1.0, 1.0);
+  cairo_paint (cr);
+
+  cairo_destroy (cr);
+
+  return surface;
+}
+
+static GdkPixbuf *
+render_page_to_pixbuf (PopplerPage *page,
+                       int          width,
+                       int          height,
+                       double       scale)
+{
+  GdkPixbuf *pixbuf;
+  cairo_surface_t *surface;
+
+  surface = render_page_to_surface (page, width, height, scale);
+  pixbuf = gdk_pixbuf_get_from_surface (surface, 0, 0,
+                                        cairo_image_surface_get_width (surface),
+                                        cairo_image_surface_get_height (surface));
+  cairo_surface_destroy (surface);
+
+  return pixbuf;
+}
+
 static gint32
 load_image (PopplerDocument        *doc,
             const gchar            *filename,
@@ -597,7 +837,7 @@ load_image (PopplerDocument        *doc,
       gdouble      page_width;
       gdouble      page_height;
 
-      GdkPixbuf   *buf;
+      GdkPixbuf   *pixbuf;
       gint         width;
       gint         height;
 
@@ -627,15 +867,13 @@ load_image (PopplerDocument        *doc,
           gimp_image_set_resolution (image_ID, resolution, resolution);
         }
 
-      buf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, FALSE, 8, width, height);
-
-      poppler_page_render_to_pixbuf (page, 0, 0, width, height, scale, 0, buf);
+      pixbuf = render_page_to_pixbuf (page, width, height, scale);
 
-      layer_from_pixbuf (image_ID, page_label, i, buf,
+      layer_from_pixbuf (image_ID, page_label, i, pixbuf,
                          doc_progress, 1.0 / pages->n_pages);
 
       g_free (page_label);
-      g_object_unref (buf);
+      g_object_unref(pixbuf);
 
       doc_progress = (double) (i + 1) / pages->n_pages;
       gimp_progress_update (doc_progress);
@@ -676,30 +914,22 @@ load_image (PopplerDocument        *doc,
   return image_ID;
 }
 
-static GdkPixbuf *
-get_thumbnail (PopplerDocument *doc,
-               gint             page_num,
-               gint             preferred_size)
+static cairo_surface_t *
+get_thumb_surface (PopplerDocument *doc,
+                   gint             page_num,
+                   gint             preferred_size)
 {
   PopplerPage *page;
-  GdkPixbuf   *pixbuf;
+  cairo_surface_t *surface;
 
   page = poppler_document_get_page (doc, page_num);
 
   if (! page)
     return NULL;
 
-  /* XXX: Remove conditional when we depend on poppler 0.8.0, but also
-   * add configure check to make sure POPPLER_WITH_GDK is enabled!
-   */
-#ifdef POPPLER_WITH_GDK
-  pixbuf = poppler_page_get_thumbnail_pixbuf (page);
-#else
-  pixbuf = poppler_page_get_thumbnail (page);
-#endif
-
+  surface = poppler_page_get_thumbnail (page);
 
-  if (! pixbuf)
+  if (! surface)
     {
       gdouble width;
       gdouble height;
@@ -712,15 +942,28 @@ get_thumbnail (PopplerDocument *doc,
       width  *= scale;
       height *= scale;
 
-      pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, FALSE, 8,
-                               width, height);
-
-      poppler_page_render_to_pixbuf (page,
-                                     0, 0, width, height, scale, 0, pixbuf);
+      surface = render_page_to_surface (page, width, height, scale);
     }
 
   g_object_unref (page);
 
+  return surface;
+}
+
+static GdkPixbuf *
+get_thumb_pixbuf (PopplerDocument *doc,
+                  gint             page_num,
+                  gint             preferred_size)
+{
+  cairo_surface_t *surface;
+  GdkPixbuf *pixbuf;
+
+  surface = get_thumb_surface (doc, page_num, preferred_size);
+  pixbuf = gdk_pixbuf_get_from_surface (surface, 0, 0,
+                                        cairo_image_surface_get_width (surface),
+                                        cairo_image_surface_get_height (surface));
+  cairo_surface_destroy (surface);
+
   return pixbuf;
 }
 
@@ -769,8 +1012,8 @@ thumbnail_thread (gpointer data)
       idle_data->page_no  = i;
 
       /* FIXME get preferred size from somewhere? */
-      idle_data->pixbuf = get_thumbnail (thread_data->document, i,
-                                         THUMBNAIL_SIZE);
+      idle_data->pixbuf = get_thumb_pixbuf (thread_data->document, i,
+                                            THUMBNAIL_SIZE);
 
       g_idle_add (idle_set_thumbnail, idle_data);
 
-- 
1.7.5
EOF
  
  CC="$CC $BUILD" CXX="$CXX $BUILD" ./configure --prefix=/usr \
    --libdir=/usr/$LIBSDIR --sysconfdir=/etc || return 1
  make || return 1
  make install DESTDIR=$TMPROOT || return 1
  sed -i -e 's%GNU Image Manipulation Program%Image Editor%' \
    $TMPROOT/usr/share/applications/gimp.desktop || return 1
  cd ../ || return 1
  rm -rf $DIR || return 1
}

version_check_info(){
  ADDRESS='ftp://ftp.gimp.org/pub/gimp/v%minor_version%/'
  VERSION_STRING='gimp-%version%.tar.bz2'
  ONLY_EVEN_MINORS=1
}
